// OUTIL 1 : AUTO-INDEX GENERATOR
// G√©n√©ration automatique des fichiers index.js pour auto-discovery
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export class AutoIndexGenerator {
  constructor(options = {}) {
    this.options = {
      dataRoot: path.join(__dirname, 'src', 'data'),
      templatePath: path.join(__dirname, 'templates', 'index-template.js'),
      dryRun: options.dryRun || false,
      verbose: options.verbose || false
    };
  }

  async generateAll() {
    console.log('üîß AUTO-INDEX GENERATOR - G√©n√©ration automatique des index\n');
    
    try {
      const structure = await this.scanDataStructure();
      await this.generateIndexFiles(structure);
      
      console.log('\n‚úÖ G√©n√©ration termin√©e avec succ√®s !');
      return structure;
    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration:', error.message);
      throw error;
    }
  }

  async scanDataStructure() {
    console.log('üîç Scan de la structure des donn√©es...');
    
    const structure = {
      matieres: new Map(),
      totalFiles: 0,
      errors: []
    };

    try {
      const matieres = await fs.readdir(this.options.dataRoot, { withFileTypes: true });
      
      for (const matiere of matieres) {
        if (matiere.isDirectory() && !matiere.name.startsWith('_')) {
          const matierePath = path.join(this.options.dataRoot, matiere.name);
          const matiereStructure = await this.scanMatiere(matiere.name, matierePath);
          structure.matieres.set(matiere.name, matiereStructure);
          structure.totalFiles += matiereStructure.totalFiles;
        }
      }
      
    } catch (error) {
      structure.errors.push(`Erreur scan data root: ${error.message}`);
    }

    this.logStructure(structure);
    return structure;
  }

  async scanMatiere(matiereName, matierePath) {
    const matiere = {
      name: matiereName,
      niveaux: new Map(),
      totalFiles: 0,
      errors: []
    };

    try {
      const items = await fs.readdir(matierePath, { withFileTypes: true });
      
      for (const item of items) {
        if (item.isDirectory()) {
          // C'est un niveau (6eme, 5eme, etc.)
          const niveauPath = path.join(matierePath, item.name);
          const niveauStructure = await this.scanNiveau(item.name, niveauPath);
          matiere.niveaux.set(item.name, niveauStructure);
          matiere.totalFiles += niveauStructure.subjects.length;
        } else if (item.isFile() && item.name.endsWith('.js') && !item.name.includes('index')) {
          // Fichier de niveau direct (ancien format)
          matiere.niveaux.set(path.basename(item.name, '.js'), {
            name: path.basename(item.name, '.js'),
            subjects: [item.name],
            path: matierePath
          });
          matiere.totalFiles++;
        }
      }
      
    } catch (error) {
      matiere.errors.push(`Erreur scan mati√®re ${matiereName}: ${error.message}`);
    }

    return matiere;
  }

  async scanNiveau(niveauName, niveauPath) {
    const niveau = {
      name: niveauName,
      subjects: [],
      path: niveauPath,
      errors: []
    };

    try {
      const files = await fs.readdir(niveauPath);
      
      for (const file of files) {
        if (file.endsWith('.js') && 
            !file.includes('index') && 
            !file.includes('reference') &&
            !file.includes('template')) {
          
          // Analyser le fichier pour extraire les m√©tadonn√©es
          const subjectInfo = await this.analyzeSubjectFile(path.join(niveauPath, file));
          niveau.subjects.push({
            filename: file,
            name: path.basename(file, '.js'),
            exportName: subjectInfo.exportName,
            aliases: subjectInfo.aliases,
            valid: subjectInfo.valid,
            errors: subjectInfo.errors
          });
        }
      }
      
    } catch (error) {
      niveau.errors.push(`Erreur scan niveau ${niveauName}: ${error.message}`);
    }

    return niveau;
  }

  async analyzeSubjectFile(filePath) {
    const analysis = {
      exportName: null,
      aliases: [],
      valid: false,
      errors: []
    };

    try {
      const content = await fs.readFile(filePath, 'utf-8');
      
      // Extraire l'export principal
      const exportMatches = content.match(/export\s+const\s+(\w+)/g);
      if (exportMatches) {
        analysis.exportName = exportMatches[0].match(/export\s+const\s+(\w+)/)[1];
      }

      // Extraire les exports nomm√©s (aliases)
      const namedExportMatches = content.match(/export\s*{\s*([^}]+)\s*}/g);
      if (namedExportMatches) {
        namedExportMatches.forEach(match => {
          const names = match.match(/{\s*([^}]+)\s*}/)[1];
          const aliases = names.split(',').map(name => name.trim());
          analysis.aliases.push(...aliases);
        });
      }

      // V√©rifier export par d√©faut
      const hasDefaultExport = content.includes('export default');

      analysis.valid = !!(analysis.exportName && hasDefaultExport);
      
      if (!analysis.exportName) {
        analysis.errors.push('Aucun export const trouv√©');
      }
      if (!hasDefaultExport) {
        analysis.errors.push('Export default manquant');
      }

    } catch (error) {
      analysis.errors.push(`Erreur analyse fichier: ${error.message}`);
    }

    return analysis;
  }

  async generateIndexFiles(structure) {
    console.log('\nüìù G√©n√©ration des fichiers index...');

    // 1. G√©n√©rer index principal (src/data/index.js)
    await this.generateMainIndex(structure);

    // 2. G√©n√©rer index par mati√®re
    for (const [matiereName, matiere] of structure.matieres) {
      await this.generateMatiereIndex(matiereName, matiere);
      
      // 3. G√©n√©rer index par niveau
      for (const [niveauName, niveau] of matiere.niveaux) {
        await this.generateNiveauIndex(matiereName, niveauName, niveau);
      }
    }
  }

  async generateMainIndex(structure) {
    const imports = [];
    const exports = [];

    for (const [matiereName, matiere] of structure.matieres) {
      const importName = this.toCamelCase(matiereName);
      imports.push(`import { ${importName} } from './${matiereName}/index.js';`);
      exports.push(`  ${matiereName}: ${importName}`);
    }

    const content = `// AUTO-G√âN√âR√â - Ne pas modifier manuellement
// Fichier d'index principal g√©n√©r√© automatiquement
// Date de g√©n√©ration: ${new Date().toISOString()}

${imports.join('\n')}
import { convertToLegacyFormat } from './legacyConverter.js';

// Structure organis√©e par mati√®re et niveau
export const coursDataBySubjectAndLevel = {
${exports.join(',\n')}
};

// Export par d√©faut pour compatibilit√©
export default coursDataBySubjectAndLevel;

// Statistiques de g√©n√©ration
export const generationStats = {
  generatedAt: "${new Date().toISOString()}",
  totalMatieres: ${structure.matieres.size},
  totalFiles: ${structure.totalFiles}
};`;

    await this.writeFile('src/data/index.js', content);
    console.log('   ‚úÖ Index principal g√©n√©r√©');
  }

  async generateMatiereIndex(matiereName, matiere) {
    const imports = [];
    const exports = [];

    for (const [niveauName, niveau] of matiere.niveaux) {
      if (niveau.subjects.length > 0) {
        const importName = `${matiereName}${this.capitalizeFirst(niveauName)}Data`;
        imports.push(`import ${importName} from './${niveauName}/index.js';`);
        exports.push(`  "${niveauName}": ${importName}`);
      }
    }

    const content = `// AUTO-G√âN√âR√â - Ne pas modifier manuellement
// Index de la mati√®re: ${matiereName}
// Date de g√©n√©ration: ${new Date().toISOString()}

${imports.join('\n')}

export const ${this.toCamelCase(matiereName)} = {
${exports.join(',\n')}
};

export default ${this.toCamelCase(matiereName)};`;

    await this.writeFile(`src/data/${matiereName}/index.js`, content);
    console.log(`   ‚úÖ Index ${matiereName} g√©n√©r√©`);
  }

  async generateNiveauIndex(matiereName, niveauName, niveau) {
    if (niveau.subjects.length === 0) return;

    const imports = [];
    const exports = [];

    for (const subject of niveau.subjects) {
      if (subject.valid && subject.exportName) {
        imports.push(`import { ${subject.exportName} } from './${subject.filename}';`);
        exports.push(`  "${subject.name}": ${subject.exportName}`);
        
        // Ajouter les aliases
        if (subject.aliases.length > 0) {
          for (const alias of subject.aliases) {
            if (alias !== subject.exportName) {
              exports.push(`  "${alias}": ${subject.exportName}`);
            }
          }
        }
      }
    }

    const content = `// AUTO-G√âN√âR√â - Ne pas modifier manuellement
// Index du niveau: ${niveauName} - Mati√®re: ${matiereName}
// Date de g√©n√©ration: ${new Date().toISOString()}

${imports.join('\n')}

const ${matiereName}${this.capitalizeFirst(niveauName)}Data = {
${exports.join(',\n')}
};

export default ${matiereName}${this.capitalizeFirst(niveauName)}Data;

// Statistiques
export const stats = {
  niveau: "${niveauName}",
  matiere: "${matiereName}",
  totalSujets: ${niveau.subjects.length},
  validSujets: ${niveau.subjects.filter(s => s.valid).length}
};`;

    await this.writeFile(`src/data/${matiereName}/${niveauName}/index.js`, content);
    console.log(`   ‚úÖ Index ${matiereName}/${niveauName} g√©n√©r√©`);
  }

  async writeFile(relativePath, content) {
    const fullPath = path.join(__dirname, relativePath);
    
    if (this.options.dryRun) {
      console.log(`   [DRY-RUN] √âcriture de ${relativePath}`);
      return;
    }

    try {
      await fs.mkdir(path.dirname(fullPath), { recursive: true });
      await fs.writeFile(fullPath, content, 'utf-8');
      
      if (this.options.verbose) {
        console.log(`   üìù Fichier √©crit: ${relativePath}`);
      }
    } catch (error) {
      console.error(`   ‚ùå Erreur √©criture ${relativePath}: ${error.message}`);
      throw error;
    }
  }

  logStructure(structure) {
    console.log(`\nüìä Structure d√©tect√©e:`);
    console.log(`   ‚Ä¢ Total mati√®res: ${structure.matieres.size}`);
    console.log(`   ‚Ä¢ Total fichiers: ${structure.totalFiles}`);
    
    for (const [matiereName, matiere] of structure.matieres) {
      console.log(`   üìö ${matiereName}:`);
      for (const [niveauName, niveau] of matiere.niveaux) {
        const validCount = niveau.subjects.filter(s => s.valid).length;
        console.log(`      ‚Ä¢ ${niveauName}: ${niveau.subjects.length} sujets (${validCount} valides)`);
      }
    }
    
    if (structure.errors.length > 0) {
      console.log(`\n‚ö†Ô∏è  Erreurs d√©tect√©es:`);
      structure.errors.forEach(error => console.log(`   ‚Ä¢ ${error}`));
    }
  }

  // Utilitaires
  toCamelCase(str) {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  }

  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

// CLI Usage
if (import.meta.url === `file://${process.argv[1]}`) {
  const options = {
    dryRun: process.argv.includes('--dry-run'),
    verbose: process.argv.includes('--verbose')
  };

  const generator = new AutoIndexGenerator(options);
  generator.generateAll().catch(console.error);
}
